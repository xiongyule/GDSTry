{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# PDK\n",
    "\n",
    "gdsfactory includes a generic PDK, that you can use as an inspiration to create your own pdks.\n",
    "\n",
    "The PDK allows you to register:\n",
    "\n",
    "- `cell` functions that return Components from a ComponentSpec (string, Component, ComponentFactory or dict). Also known as PCells (parametric cells).\n",
    "- `cross_section` functions that return CrossSection from a CrossSection Spec (string, CrossSection, CrossSectionFactory or dict).\n",
    "- `layers` that return a GDS Layer from a string, an int or a Tuple[int, int].\n",
    "\n",
    "\n",
    "You can only have one active PDK at a time.\n",
    "Thanks to PDK you can access components, cross_sections or layers using a string.\n",
    "\n",
    "Depending on the active pdk:\n",
    "\n",
    "- `get_layer` returns a Layer from the registered layers.\n",
    "- `get_component` returns a Component from the registered cells or containers.\n",
    "- `get_cross_section` returns a CrossSection from the registered cross_sections."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## layers\n",
    "\n",
    "GDS layers are a tuple of two integer number `gdslayer/gdspurpose`\n",
    "\n",
    "You can define all the layers from your PDK:\n",
    "\n",
    "1. From a Klayout `lyp` (layer properties file).\n",
    "2. From scratch, adding all your layers into a class.\n",
    "\n",
    "\n",
    "Lets generate the layers definition code from a klayout `lyp` file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "from gdsfactory.layers import lyp_to_dataclass\n",
    "from gdsfactory.config import PATH\n",
    "\n",
    "print(lyp_to_dataclass(PATH.klayout_lyp))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pydantic import BaseModel\n",
    "from gdsfactory.types import Layer\n",
    "\n",
    "\n",
    "class LayerMap(BaseModel):\n",
    "    WG: Layer = (1, 0)\n",
    "    DEVREC: Layer = (68, 0)\n",
    "    PORT: Layer = (1, 10)\n",
    "    PORTE: Layer = (1, 11)\n",
    "    LABEL: Layer = (201, 0)\n",
    "    LABEL_INSTANCES: Layer = (206, 0)\n",
    "    LABEL_SETTINGS: Layer = (202, 0)\n",
    "    LUMERICAL: Layer = (733, 0)\n",
    "    M1: Layer = (41, 0)\n",
    "    M2: Layer = (45, 0)\n",
    "    M3: Layer = (49, 0)\n",
    "    N: Layer = (20, 0)\n",
    "    NP: Layer = (22, 0)\n",
    "    NPP: Layer = (24, 0)\n",
    "    OXIDE_ETCH: Layer = (6, 0)\n",
    "    P: Layer = (21, 0)\n",
    "    PDPP: Layer = (27, 0)\n",
    "    PP: Layer = (23, 0)\n",
    "    PPP: Layer = (25, 0)\n",
    "    PinRec: Layer = (1, 10)\n",
    "    PinRecM: Layer = (1, 11)\n",
    "    SHALLOWETCH: Layer = (2, 6)\n",
    "    SILICIDE: Layer = (39, 0)\n",
    "    SIM_REGION: Layer = (100, 0)\n",
    "    SITILES: Layer = (190, 0)\n",
    "    SLAB150: Layer = (2, 0)\n",
    "    SLAB150CLAD: Layer = (2, 9)\n",
    "    SLAB90: Layer = (3, 0)\n",
    "    SLAB90CLAD: Layer = (3, 1)\n",
    "    SOURCE: Layer = (110, 0)\n",
    "    TE: Layer = (203, 0)\n",
    "    TEXT: Layer = (66, 0)\n",
    "    TM: Layer = (204, 0)\n",
    "    Text: Layer = (66, 0)\n",
    "    VIA1: Layer = (44, 0)\n",
    "    VIA2: Layer = (43, 0)\n",
    "    VIAC: Layer = (40, 0)\n",
    "    WGCLAD: Layer = (111, 0)\n",
    "    WGN: Layer = (34, 0)\n",
    "    WGNCLAD: Layer = (36, 0)\n",
    "\n",
    "    class Config:\n",
    "        frozen = True\n",
    "        extra = \"forbid\"\n",
    "\n",
    "\n",
    "LAYER = LayerMap()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are some default layers in some generic components and cross_sections, that it may be convenient adding.\n",
    "\n",
    "| Layer          | Purpose                                                      |\n",
    "| -------------- | ------------------------------------------------------------ |\n",
    "| DEVREC         | device recognition layer. For connectivity checks.           |\n",
    "| PORT           | optical port pins. For connectivity checks.                  |\n",
    "| PORTE          | electrical port pins. For connectivity checks.               |\n",
    "| SHOW_PORTS     | add port pin markers when `Component.show(show_ports=True)`  |\n",
    "| LABEL          | for adding labels to grating couplers for automatic testing. |\n",
    "| LABEL_INSTANCE | for adding instance labels on `gf.read.from_yaml`            |\n",
    "| TE             | for TE polarization fiber marker.                            |\n",
    "| TM             | for TM polarization fiber marker.                            |\n",
    "\n",
    "\n",
    "```python\n",
    "class LayersConvenient(BaseModel):\n",
    "    DEVREC: Layer = (68, 0)\n",
    "    PORT: Layer = (1, 10)  # PinRec optical\n",
    "    PORTE: Layer = (1, 11)  # PinRec electrical\n",
    "    SHOW_PORTS: Layer = (1, 12)\n",
    "\n",
    "    LABEL: Layer = (201, 0)\n",
    "    LABEL_INSTANCE: Layer = (66, 0)\n",
    "    TE: Layer = (203, 0)\n",
    "    TM: Layer = (204, 0)\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## cross_sections\n",
    "\n",
    "You can create a `CrossSection` from scratch or you can customize the cross_section functions in `gf.cross_section`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "strip2 = gf.partial(gf.cross_section.strip, layer=(2, 0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.straight(cross_section=strip2)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "pin = gf.partial(\n",
    "    gf.cross_section.strip,\n",
    "    sections=(\n",
    "        gf.tech.Section(width=2, layer=gf.LAYER.N, offset=+1),\n",
    "        gf.tech.Section(width=2, layer=gf.LAYER.P, offset=-1),\n",
    "    ),\n",
    ")\n",
    "c = gf.components.straight(cross_section=pin)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "strip_wide = gf.partial(gf.cross_section.strip, width=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "strip = gf.partial(\n",
    "    gf.cross_section.strip, auto_widen=True\n",
    ")  # auto_widen tapers to wider waveguides for lower loss in long straight sections."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cross_sections = dict(strip_wide=strip_wide, pin=pin, strip=strip)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## cells\n",
    "\n",
    "Cells are functions that return Components. They are parametrized and accept also cells as parameters, so you can build many levels of complexity. Cells are also known as PCells or parametric cells.\n",
    "\n",
    "You can customize the function default arguments easily thanks to `functools.partial`\n",
    "Lets customize the default arguments of a library of cells.\n",
    "\n",
    "For example, you can make some wide MMIs for a particular technology. Lets say the best MMI width you found it to be 9um."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "\n",
    "mmi1x2 = gf.partial(gf.components.mmi1x2, width_mmi=9)\n",
    "mmi2x2 = gf.partial(gf.components.mmi2x2, width_mmi=9)\n",
    "\n",
    "cells = dict(mmi1x2=mmi1x2, mmi2x2=mmi2x2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## PDK\n",
    "\n",
    "You can register Layers, ComponentFactories (Parametric cells) and CrossSectionFactories (cross_sections) into a PDK. Then you can access them by a string after you activate the pdk `PDK.activate()`.\n",
    "\n",
    "### LayerSpec\n",
    "\n",
    "You can access layers from the active Pdk using the layer name or a tuple/list of two numbers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1 = gf.Pdk(\n",
    "    name=\"fab1\",\n",
    "    layers=LAYER.dict(),\n",
    "    cross_sections=cross_sections,\n",
    "    cells=cells,\n",
    "    base_pdk=gf.pdk.GENERIC,\n",
    "    sparameters_path=gf.config.sparameters_path,\n",
    "    layer_colors=gf.layers.LAYER_COLORS,\n",
    ")\n",
    "pdk1.activate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1.get_layer(\"WG\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1.get_layer([1, 0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### CrossSectionSpec\n",
    "\n",
    "You can access cross_sections from the pdk from the cross_section name, or using a dict to customize the CrossSection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1.get_cross_section(\"pin\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cross_section_spec_string = \"pin\"\n",
    "gf.components.straight(cross_section=cross_section_spec_string)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cross_section_spec_dict = dict(cross_section=\"pin\", settings=dict(width=2))\n",
    "print(pdk1.get_cross_section(cross_section_spec_dict))\n",
    "wg_pin = gf.components.straight(cross_section=cross_section_spec_dict)\n",
    "wg_pin"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### ComponentSpec\n",
    "\n",
    "You can get Component from the pdk using the cell name (string) or a dict.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1.get_component(\"mmi1x2\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pdk1.get_component(dict(component=\"mmi1x2\", settings=dict(length_mmi=10)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now you can define PDKs for different Fabs\n",
    "\n",
    "### FabA\n",
    "\n",
    "FabA only has one waveguide layer available that is defined in GDS layer (30, 0)\n",
    "\n",
    "The waveguide traces are 2um wide."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "from gdsfactory.types import Layer, LayerColors, LayerColor, LayerStack, LayerLevel\n",
    "from pydantic import BaseModel\n",
    "\n",
    "nm = 1e-3\n",
    "\n",
    "\n",
    "class LayerMap(BaseModel):\n",
    "    WG: Layer = (34, 0)\n",
    "    SLAB150: Layer = (2, 0)\n",
    "    DEVREC: Layer = (68, 0)\n",
    "    PORT: Layer = (1, 10)\n",
    "    PORTE: Layer = (1, 11)\n",
    "    TE: Layer = (203, 0)\n",
    "    TM: Layer = (204, 0)\n",
    "    TEXT: Layer = (66, 0)\n",
    "\n",
    "\n",
    "LAYER = LayerMap()\n",
    "\n",
    "layer_colors = dict(\n",
    "    WG=LayerColor(gds_layer=34, gds_datatype=0, color=\"gold\"),\n",
    "    SLAB150=LayerColor(gds_layer=2, gds_datatype=0, color=\"red\"),\n",
    "    TE=LayerColor(gds_layer=203, gds_datatype=0, color=\"green\"),\n",
    ")\n",
    "LAYER_COLORS = LayerColors(layers=layer_colors)\n",
    "\n",
    "\n",
    "def get_layer_stack_faba(\n",
    "    thickness_wg: float = 500 * nm, thickness_slab: float = 150 * nm\n",
    ") -> LayerStack:\n",
    "    \"\"\"Returns fabA LayerStack\"\"\"\n",
    "    ## TODO: Translate xml in lumerical process file\n",
    "    return LayerStack(\n",
    "        layers=dict(\n",
    "            strip=LayerLevel(\n",
    "                layer=LAYER.WG,\n",
    "                thickness=thickness_wg,\n",
    "                zmin=0.0,\n",
    "                material=\"si\",\n",
    "            ),\n",
    "            strip2=LayerLevel(\n",
    "                layer=LAYER.SLAB150,\n",
    "                thickness=thickness_slab,\n",
    "                zmin=0.0,\n",
    "                material=\"si\",\n",
    "            ),\n",
    "        )\n",
    "    )\n",
    "\n",
    "\n",
    "LAYER_STACK = get_layer_stack_faba()\n",
    "\n",
    "WIDTH = 2\n",
    "\n",
    "# Specify a cross_section to use\n",
    "strip = gf.partial(gf.cross_section.cross_section, width=WIDTH, layer=LAYER.WG)\n",
    "\n",
    "mmi1x2 = gf.partial(\n",
    "    gf.components.mmi1x2,\n",
    "    width=WIDTH,\n",
    "    width_taper=WIDTH,\n",
    "    width_mmi=3 * WIDTH,\n",
    "    cross_section=strip,\n",
    ")\n",
    "\n",
    "generic_pdk = gf.pdk.GENERIC\n",
    "\n",
    "fab_a = gf.Pdk(\n",
    "    name=\"Fab_A\",\n",
    "    cells=dict(mmi1x2=mmi1x2),\n",
    "    cross_sections=dict(strip=strip),\n",
    "    layers=LAYER.dict(),\n",
    "    base_pdk=generic_pdk,\n",
    "    sparameters_path=gf.config.sparameters_path,\n",
    "    layer_colors=LAYER_COLORS,\n",
    "    layer_stack=LAYER_STACK,\n",
    ")\n",
    "fab_a.activate()\n",
    "\n",
    "gc = gf.partial(\n",
    "    gf.components.grating_coupler_elliptical_te, layer=LAYER.WG, cross_section=strip\n",
    ")\n",
    "\n",
    "c = gf.components.mzi()\n",
    "c_gc = gf.routing.add_fiber_array(component=c, grating_coupler=gc, with_loopback=False)\n",
    "c_gc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = c_gc.to_3d()\n",
    "c.show(show_ports=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### FabB\n",
    "\n",
    "FabB has photonic waveguides that require rectangular cladding layers to avoid dopants\n",
    "\n",
    "Lets say that the waveguides are defined in layer (2, 0) and are 0.3um wide, 1um thick\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "from gdsfactory.types import Layer, LayerColor, LayerColors, LayerStack, LayerLevel\n",
    "from pydantic import BaseModel\n",
    "\n",
    "nm = 1e-3\n",
    "\n",
    "\n",
    "class LayerMap(BaseModel):\n",
    "    WG: Layer = (2, 0)\n",
    "    SLAB150: Layer = (3, 0)\n",
    "    DEVREC: Layer = (68, 0)\n",
    "    PORT: Layer = (1, 10)\n",
    "    PORTE: Layer = (1, 11)\n",
    "    TE: Layer = (203, 0)\n",
    "    TM: Layer = (204, 0)\n",
    "    TEXT: Layer = (66, 0)\n",
    "    LABEL: Layer = (201, 0)\n",
    "    DOPING_BLOCK1: Layer = (61, 0)\n",
    "    DOPING_BLOCK2: Layer = (62, 0)\n",
    "\n",
    "\n",
    "LAYER = LayerMap()\n",
    "\n",
    "layer_colors = dict(\n",
    "    WG=LayerColor(gds_layer=2, gds_datatype=0, color=\"red\"),\n",
    "    SLAB150=LayerColor(gds_layer=3, gds_datatype=0, color=\"blue\"),\n",
    "    TE=LayerColor(gds_layer=203, gds_datatype=0, color=\"green\"),\n",
    "    PORT=LayerColor(gds_layer=1, gds_datatype=10, color=\"green\", alpha=0),\n",
    "    DOPING_BLOCK1=LayerColor(gds_layer=61, gds_datatype=0, color=\"green\", alpha=0),\n",
    "    DOPING_BLOCK2=LayerColor(gds_layer=62, gds_datatype=0, color=\"green\", alpha=0),\n",
    ")\n",
    "LAYER_COLORS = LayerColors(layers=layer_colors)\n",
    "\n",
    "\n",
    "def get_layer_stack_fab_b(\n",
    "    thickness_wg: float = 1000 * nm, thickness_slab: float = 150 * nm\n",
    ") -> LayerStack:\n",
    "    \"\"\"Returns fabA LayerStack\"\"\"\n",
    "    ## TODO: Translate xml in lumerical process file\n",
    "    return LayerStack(\n",
    "        layers=dict(\n",
    "            strip=LayerLevel(\n",
    "                layer=LAYER.WG,\n",
    "                thickness=thickness_wg,\n",
    "                zmin=0.0,\n",
    "                material=\"si\",\n",
    "            ),\n",
    "            strip2=LayerLevel(\n",
    "                layer=LAYER.SLAB150,\n",
    "                thickness=thickness_slab,\n",
    "                zmin=0.0,\n",
    "                material=\"si\",\n",
    "            ),\n",
    "        )\n",
    "    )\n",
    "\n",
    "\n",
    "LAYER_STACK = get_layer_stack_fab_b()\n",
    "\n",
    "\n",
    "WIDTH = 0.3\n",
    "BBOX_LAYERS = (LAYER.DOPING_BLOCK1, LAYER.DOPING_BLOCK2)\n",
    "BBOX_OFFSETS = (3, 3)\n",
    "\n",
    "# use cladding_layers and cladding_offsets if the foundry prefers conformal blocking doping layers instead of squared\n",
    "# bbox_layers and bbox_offsets makes rectangular waveguides.\n",
    "strip = gf.partial(\n",
    "    gf.cross_section.cross_section,\n",
    "    width=WIDTH,\n",
    "    layer=LAYER.WG,\n",
    "    # bbox_layers=BBOX_LAYERS,\n",
    "    # bbox_offsets=BBOX_OFFSETS,\n",
    "    cladding_layers=BBOX_LAYERS,\n",
    "    cladding_offsets=BBOX_OFFSETS,\n",
    ")\n",
    "\n",
    "straight = gf.partial(gf.components.straight, cross_section=strip)\n",
    "bend_euler = gf.partial(gf.components.bend_euler, cross_section=strip)\n",
    "mmi1x2 = gf.partial(\n",
    "    gf.components.mmi1x2,\n",
    "    cross_section=strip,\n",
    "    width=WIDTH,\n",
    "    width_taper=WIDTH,\n",
    "    width_mmi=4 * WIDTH,\n",
    ")\n",
    "mzi = gf.partial(gf.components.mzi, cross_section=strip, splitter=mmi1x2)\n",
    "gc = gf.partial(\n",
    "    gf.components.grating_coupler_elliptical_te, layer=LAYER.WG, cross_section=strip\n",
    ")\n",
    "\n",
    "cells = dict(\n",
    "    gc=gc,\n",
    "    mzi=mzi,\n",
    "    mmi1x2=mmi1x2,\n",
    "    bend_euler=bend_euler,\n",
    "    straight=straight,\n",
    "    taper=gf.components.taper,\n",
    ")\n",
    "cross_sections = dict(strip=strip)\n",
    "\n",
    "pdk = gf.Pdk(\n",
    "    name=\"fab_b\",\n",
    "    cells=cells,\n",
    "    cross_sections=cross_sections,\n",
    "    layers=LAYER.dict(),\n",
    "    sparameters_path=gf.config.sparameters_path,\n",
    "    layer_colors=LAYER_COLORS,\n",
    "    layer_stack=LAYER_STACK,\n",
    ")\n",
    "pdk.activate()\n",
    "\n",
    "\n",
    "c = mzi()\n",
    "wg_gc = gf.routing.add_fiber_array(\n",
    "    component=c, grating_coupler=gc, cross_section=strip, with_loopback=False\n",
    ")\n",
    "wg_gc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = wg_gc.to_3d()\n",
    "c.show(show_ports=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### FabC\n",
    "\n",
    "Lets assume that fab C has similar technology to the generic PDK in gdsfactory and that you just want to remap some layers, and adjust the widths.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "from typing import Callable, Dict, Optional, Tuple\n",
    "from pydantic import BaseModel\n",
    "\n",
    "import gdsfactory as gf\n",
    "from gdsfactory.add_pins import add_pin_rectangle_inside\n",
    "from gdsfactory.component import Component\n",
    "from gdsfactory.cross_section import cross_section\n",
    "from gdsfactory.tech import LayerLevel, LayerStack\n",
    "from gdsfactory.types import Layer, LayerColor, LayerColors\n",
    "\n",
    "\n",
    "nm = 1e-3\n",
    "\n",
    "\n",
    "class LayerMap(BaseModel):\n",
    "    WG: Layer = (10, 1)\n",
    "    WG_CLAD: Layer = (10, 2)\n",
    "    WGN: Layer = (34, 0)\n",
    "    WGN_CLAD: Layer = (36, 0)\n",
    "    SLAB150: Layer = (2, 0)\n",
    "    DEVREC: Layer = (68, 0)\n",
    "    PORT: Layer = (1, 10)\n",
    "    PORTE: Layer = (1, 11)\n",
    "    TE: Layer = (203, 0)\n",
    "    TM: Layer = (204, 0)\n",
    "    TEXT: Layer = (66, 0)\n",
    "    LABEL: Layer = (201, 0)\n",
    "\n",
    "\n",
    "LAYER = LayerMap()\n",
    "WIDTH_NITRIDE_OBAND = 0.9\n",
    "WIDTH_NITRIDE_CBAND = 1.0\n",
    "PORT_TYPE_TO_LAYER = dict(optical=(100, 0))\n",
    "\n",
    "# This is something you usually define in klayout\n",
    "layer_colors = dict(\n",
    "    WG=LayerColor(gds_layer=10, gds_datatype=1, color=\"black\"),\n",
    "    SLAB150=LayerColor(gds_layer=2, gds_datatype=0, color=\"blue\"),\n",
    "    WGN=LayerColor(gds_layer=34, gds_datatype=0, color=\"orange\"),\n",
    "    WGN_CLAD=LayerColor(gds_layer=36, gds_datatype=0, color=\"blue\", alpha=0),\n",
    "    TE=LayerColor(gds_layer=203, gds_datatype=0, color=\"green\"),\n",
    "    PORT=LayerColor(gds_layer=1, gds_datatype=10, color=\"green\", alpha=0),\n",
    "    DOPING_BLOCK1=LayerColor(gds_layer=61, gds_datatype=0, color=\"green\", alpha=0),\n",
    "    DOPING_BLOCK2=LayerColor(gds_layer=62, gds_datatype=0, color=\"green\", alpha=0),\n",
    ")\n",
    "LAYER_COLORS = LayerColors(layers=layer_colors)\n",
    "\n",
    "\n",
    "def get_layer_stack_fab_c(\n",
    "    thickness_wg: float = 350.0 * nm, thickness_clad: float = 3.0\n",
    ") -> LayerStack:\n",
    "    \"\"\"Returns generic LayerStack\"\"\"\n",
    "    return LayerStack(\n",
    "        layers=dict(\n",
    "            core=LayerLevel(\n",
    "                layer=LAYER.WGN,\n",
    "                thickness=thickness_wg,\n",
    "                zmin=0,\n",
    "            ),\n",
    "            clad=LayerLevel(\n",
    "                layer=LAYER.WGN_CLAD,\n",
    "                thickness=0,\n",
    "                zmin=0,\n",
    "            ),\n",
    "        )\n",
    "    )\n",
    "\n",
    "\n",
    "LAYER_STACK = get_layer_stack_fab_c()\n",
    "\n",
    "\n",
    "def add_pins(\n",
    "    component: Component,\n",
    "    function: Callable = add_pin_rectangle_inside,\n",
    "    pin_length: float = 0.5,\n",
    "    port_layer: Layer = LAYER.PORT,\n",
    "    **kwargs,\n",
    ") -> Component:\n",
    "    \"\"\"Add Pin port markers.\n",
    "\n",
    "    Args:\n",
    "        component: to add ports.\n",
    "        function:\n",
    "        pin_length:\n",
    "        port_layer:\n",
    "        function: kwargs.\n",
    "\n",
    "    \"\"\"\n",
    "    for p in component.ports.values():\n",
    "        function(\n",
    "            component=component,\n",
    "            port=p,\n",
    "            layer=port_layer,\n",
    "            layer_label=port_layer,\n",
    "            pin_length=pin_length,\n",
    "            **kwargs,\n",
    "        )\n",
    "    return component\n",
    "\n",
    "\n",
    "# cross_sections\n",
    "\n",
    "bbox_layers = [LAYER.WGN_CLAD]\n",
    "bbox_offsets = [3]\n",
    "\n",
    "\n",
    "# Nitride Cband\n",
    "xs_nc = gf.partial(\n",
    "    cross_section,\n",
    "    width=WIDTH_NITRIDE_CBAND,\n",
    "    layer=LAYER.WGN,\n",
    "    bbox_layers=bbox_layers,\n",
    "    bbox_offsets=bbox_offsets,\n",
    "    add_pins=add_pins,\n",
    ")\n",
    "# Nitride Oband\n",
    "xs_no = gf.partial(\n",
    "    cross_section,\n",
    "    width=WIDTH_NITRIDE_OBAND,\n",
    "    layer=LAYER.WGN,\n",
    "    bbox_layers=bbox_layers,\n",
    "    bbox_offsets=bbox_offsets,\n",
    "    add_pins=add_pins,\n",
    ")\n",
    "\n",
    "\n",
    "cross_sections = dict(xs_nc=xs_nc, xs_no=xs_no, strip=xs_nc)\n",
    "\n",
    "# LEAF cells have pins\n",
    "mmi1x2_nc = gf.partial(\n",
    "    gf.components.mmi1x2,\n",
    "    width=WIDTH_NITRIDE_CBAND,\n",
    "    cross_section=xs_nc,\n",
    ")\n",
    "mmi1x2_no = gf.partial(\n",
    "    gf.components.mmi1x2,\n",
    "    width=WIDTH_NITRIDE_OBAND,\n",
    "    cross_section=xs_no,\n",
    ")\n",
    "bend_euler_nc = gf.partial(\n",
    "    gf.components.bend_euler,\n",
    "    cross_section=xs_nc,\n",
    ")\n",
    "straight_nc = gf.partial(\n",
    "    gf.components.straight,\n",
    "    cross_section=xs_nc,\n",
    ")\n",
    "bend_euler_no = gf.partial(\n",
    "    gf.components.bend_euler,\n",
    "    cross_section=xs_no,\n",
    ")\n",
    "straight_no = gf.partial(\n",
    "    gf.components.straight,\n",
    "    cross_section=xs_no,\n",
    ")\n",
    "\n",
    "gc_nc = gf.partial(\n",
    "    gf.components.grating_coupler_elliptical_te,\n",
    "    grating_line_width=0.6,\n",
    "    layer=LAYER.WGN,\n",
    "    cross_section=xs_nc,\n",
    ")\n",
    "\n",
    "# HIERARCHICAL cells are made of leaf cells\n",
    "mzi_nc = gf.partial(\n",
    "    gf.components.mzi,\n",
    "    cross_section=xs_nc,\n",
    "    splitter=mmi1x2_nc,\n",
    "    straight=straight_nc,\n",
    "    bend=bend_euler_nc,\n",
    ")\n",
    "mzi_no = gf.partial(\n",
    "    gf.components.mzi,\n",
    "    cross_section=xs_no,\n",
    "    splitter=mmi1x2_no,\n",
    "    straight=straight_no,\n",
    "    bend=bend_euler_no,\n",
    ")\n",
    "\n",
    "\n",
    "cells = dict(\n",
    "    mmi1x2_nc=mmi1x2_nc,\n",
    "    mmi1x2_no=mmi1x2_no,\n",
    "    bend_euler_nc=bend_euler_nc,\n",
    "    bend_euler_no=bend_euler_no,\n",
    "    straight_nc=straight_nc,\n",
    "    straight_no=straight_no,\n",
    "    gc_nc=gc_nc,\n",
    "    mzi_nc=mzi_nc,\n",
    "    mzi_no=mzi_no,\n",
    ")\n",
    "\n",
    "pdk = gf.Pdk(\n",
    "    name=\"fab_c\",\n",
    "    cells=cells,\n",
    "    cross_sections=cross_sections,\n",
    "    layers=LAYER.dict(),\n",
    "    sparameters_path=gf.config.sparameters_path,\n",
    "    layer_colors=LAYER_COLORS,\n",
    "    layer_stack=LAYER_STACK,\n",
    ")\n",
    "pdk.activate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi = mzi_nc()\n",
    "mzi_gc = gf.routing.add_fiber_single(\n",
    "    component=mzi,\n",
    "    grating_coupler=gc_nc,\n",
    "    cross_section=xs_nc,\n",
    "    optical_routing_type=1,\n",
    "    straight=straight_nc,\n",
    "    bend=bend_euler_nc,\n",
    ")\n",
    "mzi_gc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = mzi_gc.to_3d()\n",
    "c.show(show_ports=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ls = get_layer_stack_fab_c()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## PDK Testing\n",
    "\n",
    "To make sure all your PDK Pcells produce the components that you want, it's important to test your PDK cells.\n",
    "\n",
    "As you write your own cell functions you want to make sure you do not break or produced unwanted regressions later on. You should write tests for this.\n",
    "\n",
    "Make sure you create a `test_components.py` file for pytest to test your PDK.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"This code tests all your cells in the PDK\n",
    "\n",
    "it will test 3 things:\n",
    "\n",
    "1. difftest: will test the GDS geometry of a new GDS compared to a reference. Thanks to Klayout fast booleans.add()\n",
    "2. settings test: will compare the settings in YAML with a reference YAML file.add()\n",
    "3. ensure ports are on grid, to avoid port snapping errors that can create 1nm gaps later on when you build circuits.\n",
    "\n",
    "\"\"\"\n",
    "\n",
    "import pathlib\n",
    "\n",
    "import pytest\n",
    "from pytest_regressions.data_regression import DataRegressionFixture\n",
    "\n",
    "import gdsfactory as gf\n",
    "from gdsfactory.difftest import difftest\n",
    "\n",
    "try:\n",
    "    dirpath = pathlib.Path(__file__).absolute().with_suffix(\".gds\")\n",
    "except Exception:\n",
    "    dirpath = pathlib.Path.cwd()\n",
    "\n",
    "\n",
    "component_names = list(pdk.cells.keys())\n",
    "factory = pdk.cells\n",
    "\n",
    "\n",
    "@pytest.fixture(params=component_names, scope=\"function\")\n",
    "def component_name(request) -> str:\n",
    "    return request.param\n",
    "\n",
    "\n",
    "def test_gds(component_name: str) -> None:\n",
    "    \"\"\"Avoid regressions in GDS names, shapes and layers.\n",
    "    Runs XOR and computes the area.\"\"\"\n",
    "    component = factory[component_name]()\n",
    "    test_name = f\"fabc_{component_name}\"\n",
    "    difftest(component, test_name=test_name, dirpath=dirpath)\n",
    "\n",
    "\n",
    "def test_settings(component_name: str, data_regression: DataRegressionFixture) -> None:\n",
    "    \"\"\"Avoid regressions in component settings and ports.\"\"\"\n",
    "    component = factory[component_name]()\n",
    "    data_regression.check(component.to_dict())\n",
    "\n",
    "\n",
    "def test_assert_ports_on_grid(component_name: str):\n",
    "    \"\"\"Ensures all ports are on grid to avoid 1nm gaps\"\"\"\n",
    "    component = factory[component_name]()\n",
    "    component.assert_ports_on_grid()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## PDK decorator\n",
    "\n",
    "You can also define a PDK decorator (function) that runs over every PDK PCell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "from gdsfactory.pdk import GENERIC\n",
    "from gdsfactory.decorators import flatten_invalid_refs, has_valid_transformations\n",
    "\n",
    "GENERIC.activate()\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def _demo_non_manhattan():\n",
    "    c = gf.Component(\"bend\")\n",
    "    b = c << gf.components.bend_circular(angle=30)\n",
    "    s = c << gf.components.straight(length=5)\n",
    "    s.connect(\"o1\", b.ports[\"o2\"])\n",
    "    return c\n",
    "\n",
    "\n",
    "c1 = _demo_non_manhattan()\n",
    "print(has_valid_transformations(c1))\n",
    "c1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "if you zoom in between the bends you will see a notch between waveguides due to non-manhattan connection between the bends.\n",
    "\n",
    "![gap](https://i.imgur.com/jBEwy9T.png)\n",
    "\n",
    "You an fix it with the `flatten_invalid_refs` decorator."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c2 = _demo_non_manhattan(decorator=flatten_invalid_refs)\n",
    "print(has_valid_transformations(c2))\n",
    "c2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you zoom in the connection the decorator you can see it fixed the issue.\n",
    "\n",
    "![no gap](https://i.imgur.com/VbSgIjP.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Version control components\n",
    "\n",
    "For version control your component library you can use GIT\n",
    "\n",
    "For tracking changes you can add `Component` changelog in the Pcell docstring."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import Tuple\n",
    "\n",
    "import gdsfactory as gf\n",
    "from gdsfactory.types import LayerSpec\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def litho_ruler(\n",
    "    height: float = 2,\n",
    "    width: float = 0.5,\n",
    "    spacing: float = 2.0,\n",
    "    scale: Tuple[float, ...] = (3, 1, 1, 1, 1, 2, 1, 1, 1, 1),\n",
    "    num_marks: int = 21,\n",
    "    layer: LayerSpec = \"WG\",\n",
    ") -> gf.Component:\n",
    "    \"\"\"Ruler structure for lithographic measurement.\n",
    "\n",
    "    Includes marks of varying scales to allow for easy reading by eye.\n",
    "\n",
    "    based on phidl.geometry\n",
    "\n",
    "    Args:\n",
    "        height: Height of the ruling marks in um.\n",
    "        width: Width of the ruling marks in um.\n",
    "        spacing: Center-to-center spacing of the ruling marks in um.\n",
    "        scale: Height scale pattern of marks.\n",
    "        num_marks: Total number of marks to generate.\n",
    "        layer: Specific layer to put the ruler geometry on.\n",
    "    \"\"\"\n",
    "    D = gf.Component()\n",
    "    for n in range(num_marks):\n",
    "        h = height * scale[n % len(scale)]\n",
    "        D << gf.components.rectangle(size=(width, h), layer=layer)\n",
    "\n",
    "    D.distribute(direction=\"x\", spacing=spacing, separation=False, edge=\"x\")\n",
    "    D.align(alignment=\"ymin\")\n",
    "    D.flatten()\n",
    "    return D\n",
    "\n",
    "\n",
    "c = litho_ruler()\n",
    "c"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets assume that later on you change the code inside the Pcell and want to keep a changelog."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@gf.cell\n",
    "def litho_ruler(\n",
    "    height: float = 2,\n",
    "    width: float = 0.5,\n",
    "    spacing: float = 2.0,\n",
    "    scale: Tuple[float, ...] = (3, 1, 1, 1, 1, 2, 1, 1, 1, 1),\n",
    "    num_marks: int = 21,\n",
    "    layer: LayerSpec = \"WG\",\n",
    ") -> gf.Component:\n",
    "    \"\"\"Ruler structure for lithographic measurement.\n",
    "\n",
    "    Args:\n",
    "        height: Height of the ruling marks in um.\n",
    "        width: Width of the ruling marks in um.\n",
    "        spacing: Center-to-center spacing of the ruling marks in um.\n",
    "        scale: Height scale pattern of marks.\n",
    "        num_marks: Total number of marks to generate.\n",
    "        layer: Specific layer to put the ruler geometry on.\n",
    "\n",
    "    Notes:\n",
    "        5.6.7: distribute across y instead of x.\n",
    "    \"\"\"\n",
    "    D = gf.Component()\n",
    "    for n in range(num_marks):\n",
    "        h = height * scale[n % len(scale)]\n",
    "        ref = D << gf.components.rectangle(size=(width, h), layer=layer)\n",
    "        ref.rotate(90)\n",
    "\n",
    "    D.distribute(direction=\"y\", spacing=spacing, separation=False, edge=\"y\")\n",
    "    D.align(alignment=\"xmin\")\n",
    "    D.flatten()\n",
    "    return D\n",
    "\n",
    "\n",
    "c = litho_ruler(cache=False)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
