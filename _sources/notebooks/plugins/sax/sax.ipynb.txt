{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "1fa09f47-ec17-4d2f-abf1-94400b45731a",
   "metadata": {},
   "source": [
    "# SAX circuit simulator\n",
    "\n",
    "[SAX](https://flaport.github.io/sax/) is a circuit solver written in JAX, writing your component models in SAX enables you not only to get the function values but the gradients, this is useful for circuit optimization.\n",
    "\n",
    "This tutorial has been adapted from the SAX Quick Start.\n",
    "\n",
    "You can install sax with pip (read the SAX install instructions [here](https://github.com/flaport/sax#installation))\n",
    "\n",
    "```\n",
    "! pip install sax\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0cbb9797-1aa0-4864-8fd4-bdf6b8718b0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "import gdsfactory.simulation.sax as gs\n",
    "import gdsfactory.simulation.modes as gm\n",
    "import matplotlib.pyplot as plt\n",
    "import sax\n",
    "\n",
    "gf.config.set_plot_options(show_subports=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "acb023da-1990-4e35-b760-e837ca799d1c",
   "metadata": {},
   "source": [
    "## Scatter *dictionaries*\n",
    "\n",
    "The core datastructure for specifying scatter parameters in SAX is a dictionary... more specifically a dictionary which maps a port combination (2-tuple) to a scatter parameter (or an array of scatter parameters when considering multiple wavelengths for example). Such a specific dictionary mapping is called ann `SDict` in SAX (`SDict â‰ˆ Dict[Tuple[str,str], float]`).\n",
    "\n",
    "Dictionaries are in fact much better suited for characterizing S-parameters than, say, (jax-)numpy arrays due to the inherent sparse nature of scatter parameters. Moreover, dictionaries allow for string indexing, which makes them much more pleasant to use in this context.\n",
    "\n",
    "```\n",
    "o2            o3\n",
    "   \\        /\n",
    "    ========\n",
    "   /        \\\n",
    "o1            o4\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2baac9ad-7e2d-4c8e-993c-528928c9f35a",
   "metadata": {},
   "outputs": [],
   "source": [
    "coupling = 0.5\n",
    "kappa = coupling**0.5\n",
    "tau = (1 - coupling) ** 0.5\n",
    "coupler_dict = {\n",
    "    (\"o1\", \"o4\"): tau,\n",
    "    (\"o4\", \"o1\"): tau,\n",
    "    (\"o1\", \"o3\"): 1j * kappa,\n",
    "    (\"o3\", \"o1\"): 1j * kappa,\n",
    "    (\"o2\", \"o4\"): 1j * kappa,\n",
    "    (\"o4\", \"o2\"): 1j * kappa,\n",
    "    (\"o2\", \"o3\"): tau,\n",
    "    (\"o3\", \"o2\"): tau,\n",
    "}\n",
    "coupler_dict"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb6213ba-b169-4b16-8a9b-f38fb1bd918a",
   "metadata": {},
   "source": [
    " it can still be tedious to specify every port in the circuit manually. SAX therefore offers the `reciprocal` function, which auto-fills the reverse connection if the forward connection exist. For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f62d8110-7f6f-4b88-8167-ffbcdad36019",
   "metadata": {},
   "outputs": [],
   "source": [
    "coupler_dict = sax.reciprocal(\n",
    "    {\n",
    "        (\"o1\", \"o4\"): tau,\n",
    "        (\"o1\", \"o3\"): 1j * kappa,\n",
    "        (\"o2\", \"o4\"): 1j * kappa,\n",
    "        (\"o2\", \"o3\"): tau,\n",
    "    }\n",
    ")\n",
    "\n",
    "coupler_dict"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12f9ab3f-8645-4aee-80ac-c6946a9d657e",
   "metadata": {},
   "source": [
    "## Parametrized Models\n",
    "\n",
    "Constructing such an `SDict` is easy, however, usually we're more interested in having parametrized models for our components. To parametrize the coupler `SDict`, just wrap it in a function to obtain a SAX `Model`, which is a keyword-only function mapping to an `SDict`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9aacbe90-b8d7-4cbd-bdad-309e7d34cffa",
   "metadata": {},
   "outputs": [],
   "source": [
    "def coupler(coupling=0.5) -> sax.SDict:\n",
    "    kappa = coupling**0.5\n",
    "    tau = (1 - coupling) ** 0.5\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o4\"): tau,\n",
    "            (\"o1\", \"o3\"): 1j * kappa,\n",
    "            (\"o2\", \"o4\"): 1j * kappa,\n",
    "            (\"o2\", \"o3\"): tau,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "coupler(coupling=0.3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cc3ccb8f-6154-4cd7-8ce0-9b1a5aa8f581",
   "metadata": {},
   "outputs": [],
   "source": [
    "def waveguide(wl=1.55, wl0=1.55, neff=2.34, ng=3.4, length=10.0, loss=0.0) -> sax.SDict:\n",
    "    dwl = wl - wl0\n",
    "    dneff_dwl = (ng - neff) / wl0\n",
    "    neff = neff - dwl * dneff_dwl\n",
    "    phase = 2 * jnp.pi * neff * length / wl\n",
    "    transmission = 10 ** (-loss * length / 20) * jnp.exp(1j * phase)\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): transmission,\n",
    "        }\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7e9ca43d-8182-4443-be8d-8c7213a26ed7",
   "metadata": {},
   "source": [
    "### Waveguide model\n",
    "\n",
    "You can create a dispersive waveguide model in SAX."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1432d022-d9da-4f5c-8089-0ace00c1461d",
   "metadata": {},
   "source": [
    "Lets compute the effective index `neff` and group index `ng` for a 1550nm 500nm straight waveguide"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9dd95bd-8942-480a-97e2-b481bf256499",
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gm.find_mode_dispersion(wavelength=1.55)\n",
    "print(m.neff, m.ng)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c2c01486-7d98-4240-9c82-ef6ae112bc34",
   "metadata": {},
   "outputs": [],
   "source": [
    "straight_sc = gf.partial(gs.models.straight, neff=m.neff, ng=m.ng)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b984b918-7b58-44b7-b8f1-32a19ad7f46a",
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(straight_sc)\n",
    "plt.ylim(-1, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd9cf620-92df-4e3a-a584-7417223a062c",
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(straight_sc, phase=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f665628-5cab-4e25-80a7-35642cbe92d5",
   "metadata": {},
   "source": [
    "### Coupler model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "281b0de1-ceae-4e04-a004-4de0c94b3bdd",
   "metadata": {},
   "outputs": [],
   "source": [
    "gm.find_coupling_vs_gap?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb877b9f-a86c-4aa9-973b-5ee361b6dbd5",
   "metadata": {},
   "outputs": [],
   "source": [
    "df = gm.find_coupling_vs_gap()\n",
    "df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3cc34541-5f73-462f-a3e6-42b56d7f3b7b",
   "metadata": {},
   "source": [
    "For a 200nm gap the effective index difference `dn` is `0.02`, which means that there is 100% power coupling over 38.2um"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6b041d26-1246-4c3d-80c9-60c5eb838e08",
   "metadata": {},
   "outputs": [],
   "source": [
    "coupler_sc = gf.partial(gs.models.coupler, dn=0.02, length=0, coupling0=0)\n",
    "gs.plot_model(coupler_sc)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "054c1248-bd96-4192-892f-981b4c6f121d",
   "metadata": {},
   "source": [
    "If we ignore the coupling from the bend `coupling0 = 0` we know that for a 3dB coupling we need half of the `lc` length, which is the length needed to coupler `100%` of power."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "193184a3-ff6c-403c-b456-d43f45b1b1cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "coupler_sc = gf.partial(gs.models.coupler, dn=0.02, length=38.2 / 2, coupling0=0)\n",
    "gs.plot_model(coupler_sc)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e0c22d4-16f7-4150-bb27-da05a6b8a003",
   "metadata": {},
   "source": [
    "### FDTD Sparameters model\n",
    "\n",
    "You can also fit a model from Sparameter FDTD simulation data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe47c03f-ee34-44d5-a5d7-1e2c9cb5cd4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from gdsfactory.simulation.get_sparameters_path import get_sparameters_path_lumerical\n",
    "\n",
    "filepath = get_sparameters_path_lumerical(gf.c.mmi1x2)\n",
    "mmi1x2 = gs.read.model_from_npz(filepath=filepath)\n",
    "gs.plot_model(mmi1x2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5aa5fc8-14e2-4dce-a9d4-4d0d6f7a0743",
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(mmi1x2, ports2=(\"o2\", \"o3\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a5d13cb5-987b-440b-a719-d1ff67bbca5c",
   "metadata": {},
   "source": [
    "## Model fit\n",
    "\n",
    "You can fit a sax model to Sparameter FDTD simulation data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4c700aca-be96-4fe1-be90-46d148e0cc9d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import jax.example_libraries.optimizers as opt\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import gdsfactory as gf\n",
    "import gdsfactory.simulation.modes as gm\n",
    "import gdsfactory.simulation.sax as gs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34eaf4a2-edb2-4dd1-9856-f1a1eb9b502d",
   "metadata": {},
   "outputs": [],
   "source": [
    "coupler_fdtd = gs.read.model_from_csv(\n",
    "    filepath=gf.config.sparameters_path / \"coupler\" / \"coupler_G224n_L20_S220.csv\",\n",
    "    xkey=\"wavelength_nm\",\n",
    "    prefix=\"S\",\n",
    "    xunits=1e-3,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cb664d7e-0b19-4ffb-a904-6b7104abdd0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(coupler_fdtd)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fd6f53ba-4386-4b15-ad62-ef88510a9d03",
   "metadata": {},
   "outputs": [],
   "source": [
    "# lumerical simulation (different coupler)\n",
    "coupler_fdtd = gs.read.model_from_csv(\n",
    "    filepath=gf.config.sparameters_path / \"coupler_057254c0_00cc8908.csv\",\n",
    ")\n",
    "gs.plot_model(coupler_fdtd)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a1bd051-0525-48a8-83e5-8568f8bce8ce",
   "metadata": {},
   "source": [
    "Lets fit the coupler spectrum with a linear regression `sklearn` fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f634095b-d1f2-464a-9931-c8d252670eb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sax\n",
    "import gdsfactory as gf\n",
    "import gdsfactory.simulation.sax as gs\n",
    "import jax\n",
    "import jax.numpy as jnp\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.constants import c\n",
    "from sklearn.linear_model import LinearRegression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e5484361-3df6-4e40-a947-60fa265f71a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "f = jnp.linspace(c / 1.0e-6, c / 2.0e-6, 500) * 1e-12  # THz\n",
    "wl = c / (f * 1e12) * 1e6  # um\n",
    "\n",
    "filepath = gf.config.sparameters_path / \"coupler\" / \"coupler_G224n_L20_S220.csv\"\n",
    "coupler_fdtd = gs.read.model_from_csv(\n",
    "    filepath, xkey=\"wavelength_nm\", prefix=\"S\", xunits=1e-3\n",
    ")\n",
    "sd = coupler_fdtd(wl=wl)\n",
    "\n",
    "k = sd[\"o1\", \"o3\"]\n",
    "t = sd[\"o1\", \"o4\"]\n",
    "s = t + k\n",
    "a = t - k"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8cce6788-2af1-4c74-b5f0-4fcb45a8d5ea",
   "metadata": {},
   "source": [
    "Lets fit the symmetric (t+k) and antisymmetric (t-k) transmission\n",
    "\n",
    "### Symmetric"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1adb28b5-b2ea-496a-b5e3-cf93fab11dcd",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(wl, jnp.abs(s))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")\n",
    "plt.title(\"symmetric (transmission + coupling)\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70dec0b5-87c9-47a7-9450-a896c23dd7c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(wl, jnp.abs(a))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")\n",
    "plt.title(\"anti-symmetric (transmission - coupling)\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f8934dca-7c86-4946-85b8-277d8b3ab6ba",
   "metadata": {},
   "outputs": [],
   "source": [
    "r = LinearRegression()\n",
    "fX = lambda x, _order=8: x[:, None] ** (\n",
    "    jnp.arange(_order)[None, :]\n",
    ")  # artificially create more 'features' (wl**2, wl**3, wl**4, ...)\n",
    "X = fX(wl)\n",
    "r.fit(X, jnp.abs(s))\n",
    "asm, bsm = r.coef_, r.intercept_\n",
    "fsm = lambda x: fX(x) @ asm + bsm  # fit symmetric module fiir\n",
    "\n",
    "plt.plot(wl, jnp.abs(s))\n",
    "plt.plot(wl, fsm(wl))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "966f429b-5e50-4053-b678-00377aa85fb8",
   "metadata": {},
   "outputs": [],
   "source": [
    "r = LinearRegression()\n",
    "r.fit(X, jnp.unwrap(jnp.angle(s)))\n",
    "asp, bsp = r.coef_, r.intercept_\n",
    "fsp = lambda x: fX(x) @ asp + bsp  # fit symmetric phase\n",
    "\n",
    "plt.plot(wl, jnp.unwrap(jnp.angle(s)))\n",
    "plt.plot(wl, fsp(wl))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Angle [rad]\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62faeb50-e4b7-4f68-92ba-79ce4c74b370",
   "metadata": {},
   "outputs": [],
   "source": [
    "fs = lambda x: fsm(x) * jnp.exp(1j * fsp(x))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "415e725f-01a1-4309-937f-3d8f11fa9381",
   "metadata": {},
   "source": [
    "Lets fit the symmetric (t+k) and antisymmetric (t-k) transmission\n",
    "\n",
    "### Anti-Symmetric"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c34f17c9-3f4e-4e07-a077-ebfd33dab49d",
   "metadata": {},
   "outputs": [],
   "source": [
    "r = LinearRegression()\n",
    "r.fit(X, jnp.abs(a))\n",
    "aam, bam = r.coef_, r.intercept_\n",
    "fam = lambda x: fX(x) @ aam + bam\n",
    "\n",
    "plt.plot(wl, jnp.abs(a))\n",
    "plt.plot(wl, fam(wl))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d09113f6-558b-4529-9bff-a68ceda85204",
   "metadata": {},
   "outputs": [],
   "source": [
    "r = LinearRegression()\n",
    "r.fit(X, jnp.unwrap(jnp.angle(a)))\n",
    "aap, bap = r.coef_, r.intercept_\n",
    "fap = lambda x: fX(x) @ aap + bap\n",
    "\n",
    "plt.plot(wl, jnp.unwrap(jnp.angle(a)))\n",
    "plt.plot(wl, fap(wl))\n",
    "plt.grid(True)\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Angle [rad]\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ef257ed-0dd8-4754-81e8-3226e39e335d",
   "metadata": {},
   "outputs": [],
   "source": [
    "fa = lambda x: fam(x) * jnp.exp(1j * fap(x))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b050be26-aec0-4e1c-b9f7-0ff55857ed7a",
   "metadata": {},
   "source": [
    "### Total"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23a6debb-d8b1-4883-a4c8-1a3edaf21509",
   "metadata": {},
   "outputs": [],
   "source": [
    "t_ = 0.5 * (fs(wl) + fa(wl))\n",
    "\n",
    "plt.plot(wl, jnp.abs(t))\n",
    "plt.plot(wl, jnp.abs(t_))\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fcde546f-ba9f-44e6-8c11-a012c90326f8",
   "metadata": {},
   "outputs": [],
   "source": [
    "k_ = 0.5 * (fs(wl) - fa(wl))\n",
    "\n",
    "plt.plot(wl, jnp.abs(k))\n",
    "plt.plot(wl, jnp.abs(k_))\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Coupling\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3a31d6a7-909e-46b7-b593-33cce3986bf4",
   "metadata": {},
   "outputs": [],
   "source": [
    "@jax.jit\n",
    "def coupler(wl=1.5):\n",
    "    wl = jnp.asarray(wl)\n",
    "    wl_shape = wl.shape\n",
    "    wl = wl.ravel()\n",
    "    t = (0.5 * (fs(wl) + fa(wl))).reshape(*wl_shape)\n",
    "    k = (0.5 * (fs(wl) - fa(wl))).reshape(*wl_shape)\n",
    "    sdict = {\n",
    "        (\"o1\", \"o4\"): t,\n",
    "        (\"o1\", \"o3\"): k,\n",
    "        (\"o2\", \"o3\"): k,\n",
    "        (\"o2\", \"o4\"): t,\n",
    "    }\n",
    "    return sax.reciprocal(sdict)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c27fdcf-9287-4e7d-b75a-86806ebc048e",
   "metadata": {},
   "outputs": [],
   "source": [
    "f = jnp.linspace(c / 1.0e-6, c / 2.0e-6, 500) * 1e-12  # THz\n",
    "wl = c / (f * 1e12) * 1e6  # um\n",
    "\n",
    "filepath = gf.config.sparameters_path / \"coupler\" / \"coupler_G224n_L20_S220.csv\"\n",
    "coupler_fdtd = gs.read.model_from_csv(\n",
    "    filepath, xkey=\"wavelength_nm\", prefix=\"S\", xunits=1e-3\n",
    ")\n",
    "sd = coupler_fdtd(wl=wl)\n",
    "sd_ = coupler(wl=wl)\n",
    "\n",
    "T = jnp.abs(sd[\"o1\", \"o4\"]) ** 2\n",
    "K = jnp.abs(sd[\"o1\", \"o3\"]) ** 2\n",
    "T_ = jnp.abs(sd_[\"o1\", \"o4\"]) ** 2\n",
    "K_ = jnp.abs(sd_[\"o1\", \"o3\"]) ** 2\n",
    "dP = jnp.unwrap(jnp.angle(sd[\"o1\", \"o3\"]) - jnp.angle(sd[\"o1\", \"o4\"]))\n",
    "dP_ = jnp.unwrap(jnp.angle(sd_[\"o1\", \"o3\"]) - jnp.angle(sd_[\"o1\", \"o4\"]))\n",
    "\n",
    "plt.figure(figsize=(12, 3))\n",
    "plt.plot(wl, T, label=\"T (fdtd)\", c=\"C0\", ls=\":\", lw=\"6\")\n",
    "plt.plot(wl, T_, label=\"T (model)\", c=\"C0\")\n",
    "\n",
    "plt.plot(wl, K, label=\"K (fdtd)\", c=\"C1\", ls=\":\", lw=\"6\")\n",
    "plt.plot(wl, K_, label=\"K (model)\", c=\"C1\")\n",
    "\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.grid(True)\n",
    "\n",
    "plt.twinx()\n",
    "plt.plot(wl, dP, label=\"Î”Î¦ (fdtd)\", color=\"C2\", ls=\":\", lw=\"6\")\n",
    "plt.plot(wl, dP_, label=\"Î”Î¦ (model)\", color=\"C2\")\n",
    "\n",
    "plt.xlabel(\"Frequency [THz]\")\n",
    "plt.ylabel(\"Transmission\")\n",
    "plt.figlegend(bbox_to_anchor=(1.08, 0.9))\n",
    "plt.savefig(\"fdtd_vs_model.png\", bbox_inches=\"tight\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6fc2a468-3275-4a26-a0c8-c99a10e90df2",
   "metadata": {},
   "source": [
    "## SAX gdsfactory Compatibility\n",
    "> From Layout to Circuit Model\n",
    "\n",
    "If you define your SAX S parameter models for your components, you can directly simulate your circuits from gdsfactory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dfa5715c-dd06-4cae-a391-2230080a4283",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import jax.numpy as jnp\n",
    "from omegaconf import OmegaConf\n",
    "import sax\n",
    "from pprint import pprint\n",
    "\n",
    "import gdsfactory as gf\n",
    "from gdsfactory.get_netlist import get_netlist as _get_netlist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "80da2a80-cfbe-442a-a201-7263fda8c6df",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi = gf.components.mzi(delta_length=10)\n",
    "mzi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "64287264-61d0-4d77-96cc-8401a140f3a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "netlist = mzi.get_netlist()\n",
    "pprint(netlist[\"connections\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2aa882fe-6b2e-499e-8370-e33e5a14f486",
   "metadata": {},
   "source": [
    "The netlist has three different components:\n",
    "\n",
    "1. straight\n",
    "2. mmi1x2\n",
    "3. bend_euler\n",
    "\n",
    "You need models for each subcomponents to simulate the Component."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f497b61-d519-48cc-8a22-c6f51ede482f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def straight(wl=1.5, length=10.0, neff=2.4) -> sax.SDict:\n",
    "    wl0 = 1.5  # center wavelength for which the waveguide model is defined\n",
    "    return sax.reciprocal({(\"o1\", \"o2\"): jnp.exp(2j * jnp.pi * neff * length / wl)})\n",
    "\n",
    "\n",
    "def mmi1x2():\n",
    "    \"\"\"Assumes a perfect 1x2 splitter\"\"\"\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): 0.5**0.5,\n",
    "            (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "def bend_euler(wl=1.5, length=20.0):\n",
    "    \"\"\" \"Let's assume a reduced transmission for the euler bend compared to a straight\"\"\"\n",
    "    return {k: 0.99 * v for k, v in straight(wl=wl, length=length).items()}\n",
    "\n",
    "\n",
    "models = {\n",
    "    \"bend_euler\": bend_euler,\n",
    "    \"mmi1x2\": mmi1x2,\n",
    "    \"straight\": straight,\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c05bf3d4-e3b9-483f-a6ac-002dec46bb90",
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit, _ = sax.circuit(netlist=netlist, models=models)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3267aaac-1af2-4cae-8b87-9abb7338068a",
   "metadata": {},
   "outputs": [],
   "source": [
    "wl = np.linspace(1.5, 1.6)\n",
    "S = circuit(wl=wl)\n",
    "\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.title(\"MZI\")\n",
    "plt.plot(1e3 * wl, jnp.abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "980c2aa4-edca-4663-8777-193cbd6f1ece",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi = gf.components.mzi(delta_length=20)  # Double the length, reduces FSR by 1/2\n",
    "mzi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e0661af0-0131-41fd-a197-9bcc9d04996a",
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit, _ = sax.circuit(netlist=mzi.get_netlist(), models=models)\n",
    "\n",
    "wl = np.linspace(1.5, 1.6, 256)\n",
    "S = circuit(wl=wl)\n",
    "\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.title(\"MZI\")\n",
    "plt.plot(1e3 * wl, jnp.abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5e84074b-8cc0-40f7-8d03-3080c02c9dbb",
   "metadata": {},
   "source": [
    "## Layout aware Monte Carlo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "06260b77-0795-4484-bc7f-56407e517721",
   "metadata": {},
   "outputs": [],
   "source": [
    "import itertools\n",
    "import sys\n",
    "from functools import partial\n",
    "from typing import List\n",
    "\n",
    "import gdsfactory as gf\n",
    "import jax\n",
    "import jax.example_libraries.optimizers as opt\n",
    "import jax.numpy as jnp\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import sax\n",
    "from numpy.fft import fft2, fftfreq, fftshift, ifft2\n",
    "from tqdm.notebook import tqdm, trange"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10208c1f-2ed3-40fd-bd7b-a5d5b4167791",
   "metadata": {},
   "source": [
    "### Waveguide Model\n",
    "\n",
    "The waveguide model is not very good (it just has 100% transmission and no phase).\n",
    "You can fix the phase calculation.\n",
    "To do this, you need to find the effective index of the waveguide in relation to its parameters.\n",
    "You can use MPB mode solver to obtain the waveguide parameters from the waveguide modes thanks to `find_modes_waveguide`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bb73c78b-0eac-47b9-b359-908d5bcedb8a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def silicon_index(wl):\n",
    "    \"\"\"a rudimentary silicon refractive index model\"\"\"\n",
    "    a, b = 0.2411478522088102, 3.3229394315868976\n",
    "    return a / wl + b"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c2f81817-ea9e-43c9-9635-9fbed3f188ed",
   "metadata": {},
   "outputs": [],
   "source": [
    "from gdsfactory.simulation.modes import find_modes_waveguide\n",
    "\n",
    "wavelengths = np.linspace(1.5, 1.6, 10)\n",
    "widths = np.linspace(0.4, 0.6, 5)\n",
    "\n",
    "wavelengths, widths = np.mgrid[1.5:1.6:10j, 0.4:0.6:5j]\n",
    "neffs = np.zeros_like(wavelengths)\n",
    "neffs_ = neffs.ravel()\n",
    "\n",
    "for i, (wl, w) in enumerate(zip(tqdm(wavelengths.ravel()), widths.ravel())):\n",
    "    modes = find_modes_waveguide(\n",
    "        wavelength=wl,\n",
    "        wg_width=w,\n",
    "        mode_number=1,\n",
    "        wg_thickness=0.22,\n",
    "        slab_thickness=0.0,\n",
    "        ncore=silicon_index(wl),\n",
    "        nclad=1.4,\n",
    "    )\n",
    "    neffs_[i] = modes[1].neff"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb47daaf-0098-4a6e-be08-4cfcfb71923c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def visualize_mode(mode, field):\n",
    "    field, comp = list(field)\n",
    "    idx = [\"x\", \"y\", \"z\"].index(comp)\n",
    "    x, y = getattr(mode, \"y\"), getattr(mode, \"z\")\n",
    "    Y, X = np.meshgrid(y, x)\n",
    "    mode = np.abs(getattr(mode, field)[..., 0, idx]) ** 2\n",
    "    plt.contour(\n",
    "        X, Y, mode, cmap=\"inferno\", levels=np.linspace(mode.min(), mode.max(), 8)\n",
    "    )\n",
    "    plt.colorbar(label=\"mode\")\n",
    "    plt.grid(True, alpha=0.4)\n",
    "    plt.xlim(X.min(), X.max())\n",
    "    plt.ylim(Y.min(), Y.max())\n",
    "    plt.xlabel(\"y\")\n",
    "    plt.ylabel(\"z\")\n",
    "    plt.axis(\"scaled\")\n",
    "    plt.grid(True)\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "92c53aa8-8526-46b9-a940-0421e8f31713",
   "metadata": {},
   "outputs": [],
   "source": [
    "visualize_mode(modes[1], \"Hz\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "73aa2e6a-40c8-4adf-a693-0ad968e844b8",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.pcolormesh(wavelengths, widths, neffs)\n",
    "plt.xlabel(\"Î» [Î¼m]\")\n",
    "plt.ylabel(\"width [Î¼m]\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f4dd791c-9f7d-49f5-9ed7-08b7cc2590a7",
   "metadata": {},
   "outputs": [],
   "source": [
    "_grid = [jnp.sort(jnp.unique(wavelengths)), jnp.sort(jnp.unique(widths))]\n",
    "_data = jnp.asarray(neffs)\n",
    "\n",
    "\n",
    "@jax.jit\n",
    "def _get_coordinate(arr1d: jnp.ndarray, value: jnp.ndarray):\n",
    "    return jnp.interp(value, arr1d, jnp.arange(arr1d.shape[0]))\n",
    "\n",
    "\n",
    "@jax.jit\n",
    "def _get_coordinates(arrs1d: List[jnp.ndarray], values: jnp.ndarray):\n",
    "    # don't use vmap as arrays in arrs1d could have different shapes...\n",
    "    return jnp.array([_get_coordinate(a, v) for a, v in zip(arrs1d, values)])\n",
    "\n",
    "\n",
    "@jax.jit\n",
    "def neff(wl=1.55, width=0.5):\n",
    "    params = jnp.stack(jnp.broadcast_arrays(jnp.asarray(wl), jnp.asarray(width)), 0)\n",
    "    coords = _get_coordinates(_grid, params)\n",
    "    return jax.scipy.ndimage.map_coordinates(_data, coords, 1, mode=\"nearest\")\n",
    "\n",
    "\n",
    "neff(wl=[1.52, 1.58], width=[0.5, 0.55])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eed91ec8-359e-4bbc-9bb8-fa8ee6714d15",
   "metadata": {},
   "outputs": [],
   "source": [
    "wavelengths_ = np.linspace(wavelengths.min(), wavelengths.max(), 100)\n",
    "widths_ = np.linspace(widths.min(), widths.max(), 100)\n",
    "wavelengths_, widths_ = np.meshgrid(wavelengths_, widths_)\n",
    "neffs_ = neff(wavelengths_, widths_)\n",
    "plt.pcolormesh(wavelengths_, widths_, neffs_)\n",
    "plt.xlabel(\"Î» [Î¼m]\")\n",
    "plt.ylabel(\"width [Î¼m]\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a830533-f63b-4c8b-a38f-37524d7e3824",
   "metadata": {},
   "outputs": [],
   "source": [
    "def straight(wl=1.55, length=10.0, width=0.5):\n",
    "    S = {\n",
    "        (\"o1\", \"o2\"): jnp.exp(2j * np.pi * neff(wl=wl, width=width) / wl * length),\n",
    "    }\n",
    "    return sax.reciprocal(S)\n",
    "\n",
    "\n",
    "def mmi1x2():\n",
    "    \"\"\"Assumes a perfect 1x2 splitter\"\"\"\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): 0.5**0.5,\n",
    "            (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "def mmi2x2():\n",
    "    S = {\n",
    "        (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        (\"o1\", \"o4\"): 1j * 0.5**0.5,\n",
    "        (\"o2\", \"o3\"): 1j * 0.5**0.5,\n",
    "        (\"o2\", \"o4\"): 0.5**0.5,\n",
    "    }\n",
    "    return sax.reciprocal(S)\n",
    "\n",
    "\n",
    "def bend_euler(wl=1.5, length=20.0, width=0.5):\n",
    "    \"\"\" \"Let's assume a reduced transmission for the euler bend compared to a straight\"\"\"\n",
    "    return {k: 0.99 * v for k, v in straight(wl=wl, length=length, width=width).items()}\n",
    "\n",
    "\n",
    "models = {\n",
    "    \"bend_euler\": bend_euler,\n",
    "    \"mmi1x2\": mmi1x2,\n",
    "    \"mmi2x2\": mmi2x2,\n",
    "    \"straight\": straight,\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b75289a0-6273-4572-8714-be5e2f56b814",
   "metadata": {},
   "source": [
    "Even though this still is lossless transmission, we're at least modeling the phase correctly."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90413f3a-b1bc-4de0-b753-a61adb3286f2",
   "metadata": {},
   "outputs": [],
   "source": [
    "straight()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "40351ae9-687f-4126-9784-83d6b4d8e945",
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit, _ = sax.circuit(mzi.get_netlist(), models=models)\n",
    "circuit()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f04a3131-3755-4fd0-801f-9962e7ed4e01",
   "metadata": {},
   "outputs": [],
   "source": [
    "wl = jnp.linspace(1.51, 1.59, 1000)\n",
    "S = circuit(wl=wl)\n",
    "plt.plot(wl, abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.xlabel(\"Î» [Î¼m]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "88648c32-986e-4d7a-874d-667c40e17c64",
   "metadata": {},
   "source": [
    "### Circuit model with variability\n",
    "\n",
    "Let's assume the waveguide width changes with a certain correlation length. We can create a 'wafermap' of width variations by randomly varying the width and low pass filtering with a spatial frequency being the inverse of the correlation length (there are probably better ways to do this, but this works for this tutorial)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0685f879-f73b-4eac-ad7a-a1f15e680628",
   "metadata": {},
   "outputs": [],
   "source": [
    "def create_wafermaps(placements, correlation_length=1.0, num_maps=1, mean=0.0, std=1.0):\n",
    "    dx = dy = correlation_length / 200\n",
    "    xs, ys = [p[\"x\"] for p in placements.values()], [\n",
    "        p[\"y\"] for p in placements.values()\n",
    "    ]\n",
    "    xmin, xmax, ymin, ymax = min(xs), max(xs), min(ys), max(ys)\n",
    "    wx, wy = xmax - xmin, ymax - ymin\n",
    "    xmin, xmax, ymin, ymax = xmin - wx, xmax + wx, ymin - wy, ymax + wy\n",
    "    x, y = np.arange(xmin, xmax + dx, dx), np.arange(ymin, ymax + dy, dy)\n",
    "    W0 = np.random.randn(num_maps, x.shape[0], y.shape[0])\n",
    "\n",
    "    fx, fy = fftshift(fftfreq(x.shape[0], d=x[1] - x[0])), fftshift(\n",
    "        fftfreq(y.shape[0], d=y[1] - y[0])\n",
    "    )\n",
    "    fY, fX = np.meshgrid(fy, fx)\n",
    "    fW = fftshift(fft2(W0))\n",
    "\n",
    "    if correlation_length >= min(x.shape[0], y.shape[0]):\n",
    "        fW = np.zeros_like(fW)\n",
    "    else:\n",
    "        fW = np.where(np.sqrt(fX**2 + fY**2)[None] > 1 / correlation_length, 0, fW)\n",
    "\n",
    "    W = np.abs(fftshift(ifft2(fW))) ** 2\n",
    "    mean_ = W.mean(1, keepdims=True).mean(2, keepdims=True)\n",
    "    std_ = W.std(1, keepdims=True).std(2, keepdims=True)\n",
    "    if (std_ == 0).all():\n",
    "        std_ = 1\n",
    "\n",
    "    W = (W - mean_) / std_\n",
    "    W = W * std + mean\n",
    "    return x, y, W"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c9fbf974-786c-4ae7-9a7d-a2d8ae9a57b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "placements = mzi.get_netlist()[\"placements\"]\n",
    "xm, ym, wmaps = create_wafermaps(\n",
    "    placements, correlation_length=100, mean=0.5, std=0.002, num_maps=100\n",
    ")\n",
    "\n",
    "for i, wmap in enumerate(wmaps):\n",
    "    plt.imshow(wmap, cmap=\"RdBu\")\n",
    "    plt.show()\n",
    "    if i == 2:\n",
    "        break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3505be49-550e-497e-ba89-d35235406c99",
   "metadata": {},
   "outputs": [],
   "source": [
    "def widths(xw, yw, wmaps, x, y):\n",
    "    _wmap_grid = [xw, yw]\n",
    "    params = jnp.stack(jnp.broadcast_arrays(jnp.asarray(x), jnp.asarray(y)), 0)\n",
    "    coords = _get_coordinates(_wmap_grid, params)\n",
    "\n",
    "    map_coordinates = partial(\n",
    "        jax.scipy.ndimage.map_coordinates, coordinates=coords, order=1, mode=\"nearest\"\n",
    "    )\n",
    "    w = jax.vmap(map_coordinates)(wmaps)\n",
    "    return w"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79712481-8cdd-449e-9622-29ac093f3ea2",
   "metadata": {},
   "source": [
    "Let's now sample the MZI width variation on the wafer map (let's assume a single width variation per point):\n",
    "\n",
    "\n",
    "### Simple MZI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "742976fe-2256-4085-8f54-9ea06346ec34",
   "metadata": {},
   "outputs": [],
   "source": [
    "@gf.cell\n",
    "def simple_mzi():\n",
    "    global bend_top1_\n",
    "    c = gf.Component()\n",
    "\n",
    "    # instances\n",
    "    mmi_in = gf.components.mmi1x2()\n",
    "    mmi_out = gf.components.mmi2x2()\n",
    "    bend = gf.components.bend_euler()\n",
    "    half_delay_straight = gf.components.straight(length=10.0)\n",
    "\n",
    "    # references (sax convention: vars ending in underscore are references)\n",
    "    mmi_in_ = c << mmi_in\n",
    "    mmi_out_ = c << mmi_out\n",
    "    straight_top1_ = c << half_delay_straight\n",
    "    straight_top2_ = c << half_delay_straight\n",
    "    bend_top1_ = c << bend\n",
    "    bend_top2_ = (c << bend).mirror()\n",
    "    bend_top3_ = (c << bend).mirror()\n",
    "    bend_top4_ = c << bend\n",
    "    bend_btm1_ = (c << bend).mirror()\n",
    "    bend_btm2_ = c << bend\n",
    "    bend_btm3_ = c << bend\n",
    "    bend_btm4_ = (c << bend).mirror()\n",
    "\n",
    "    # connections\n",
    "    bend_top1_.connect(\"o1\", mmi_in_.ports[\"o2\"])\n",
    "    straight_top1_.connect(\"o1\", bend_top1_.ports[\"o2\"])\n",
    "    bend_top2_.connect(\"o1\", straight_top1_.ports[\"o2\"])\n",
    "    bend_top3_.connect(\"o1\", bend_top2_.ports[\"o2\"])\n",
    "    straight_top2_.connect(\"o1\", bend_top3_.ports[\"o2\"])\n",
    "    bend_top4_.connect(\"o1\", straight_top2_.ports[\"o2\"])\n",
    "\n",
    "    bend_btm1_.connect(\"o1\", mmi_in_.ports[\"o3\"])\n",
    "    bend_btm2_.connect(\"o1\", bend_btm1_.ports[\"o2\"])\n",
    "    bend_btm3_.connect(\"o1\", bend_btm2_.ports[\"o2\"])\n",
    "    bend_btm4_.connect(\"o1\", bend_btm3_.ports[\"o2\"])\n",
    "\n",
    "    mmi_out_.connect(\"o1\", bend_btm4_.ports[\"o2\"])\n",
    "\n",
    "    # ports\n",
    "    c.add_port(\n",
    "        \"o1\",\n",
    "        port=mmi_in_.ports[\"o1\"],\n",
    "    )\n",
    "    c.add_port(\"o2\", port=mmi_out_.ports[\"o3\"])\n",
    "    c.add_port(\"o3\", port=mmi_out_.ports[\"o4\"])\n",
    "    return c\n",
    "\n",
    "\n",
    "mzi = simple_mzi()\n",
    "mzi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c80f89eb-084b-41cb-96ce-9c058ecd2a12",
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit, _ = sax.circuit(mzi.get_netlist(), models=models)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "733a3c30-6b5e-4881-91e3-bc3f542c038d",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_params = sax.get_settings(circuit)\n",
    "placements = mzi.get_netlist()[\"placements\"]\n",
    "width_params = {\n",
    "    k: {\"width\": widths(xm, ym, wmaps, v[\"x\"], v[\"y\"])}\n",
    "    for k, v in placements.items()\n",
    "    if \"width\" in mzi_params[k]\n",
    "}\n",
    "\n",
    "S0 = circuit(wl=wl)\n",
    "S = circuit(\n",
    "    wl=wl[:, None],\n",
    "    **width_params,\n",
    ")\n",
    "ps = plt.plot(wl * 1e3, abs(S[\"o1\", \"o2\"]) ** 2, color=\"C0\", lw=1, alpha=0.1)\n",
    "nps = plt.plot(wl * 1e3, abs(S0[\"o1\", \"o2\"]) ** 2, color=\"C1\", lw=2, alpha=1)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.plot([1550, 1550], [-1, 2], color=\"black\", ls=\":\")\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.grid(True)\n",
    "plt.figlegend([*ps[-1:], *nps], [\"MC\", \"nominal\"], bbox_to_anchor=(1.1, 0.9))\n",
    "rmse = jnp.mean(\n",
    "    jnp.abs(jnp.abs(S[\"o1\", \"o2\"]) ** 2 - jnp.abs(S0[\"o1\", \"o2\"][:, None]) ** 2) ** 2\n",
    ")\n",
    "plt.title(f\"{rmse=}\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4ca3302-ecd9-413a-b991-8a72126fbff7",
   "metadata": {},
   "source": [
    "### Compact MZI\n",
    "\n",
    "Let's see if we can improve variability (i.e. the RMSE w.r.t. nominal) by making the MZI more compact:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2fde1cf1-9b93-4245-9613-d297fa567b1b",
   "metadata": {},
   "outputs": [],
   "source": [
    "@gf.cell\n",
    "def compact_mzi():\n",
    "    c = gf.Component()\n",
    "\n",
    "    # instances\n",
    "    mmi_in = gf.components.mmi1x2()\n",
    "    mmi_out = gf.components.mmi2x2()\n",
    "    bend = gf.components.bend_euler()\n",
    "    half_delay_straight = gf.components.straight()\n",
    "    middle_straight = gf.components.straight(length=6.0)\n",
    "    half_middle_straight = gf.components.straight(3.0)\n",
    "\n",
    "    # references (sax convention: vars ending in underscore are references)\n",
    "    mmi_in_ = c << mmi_in\n",
    "\n",
    "    bend_top1_ = c << bend\n",
    "    straight_top1_ = c << half_delay_straight\n",
    "    bend_top2_ = (c << bend).mirror()\n",
    "    straight_top2_ = c << middle_straight\n",
    "    bend_top3_ = (c << bend).mirror()\n",
    "    straight_top3_ = c << half_delay_straight\n",
    "    bend_top4_ = c << bend\n",
    "\n",
    "    straight_btm1_ = c << half_middle_straight\n",
    "    bend_btm1_ = c << bend\n",
    "    bend_btm2_ = (c << bend).mirror()\n",
    "    bend_btm3_ = (c << bend).mirror()\n",
    "    bend_btm4_ = c << bend\n",
    "    straight_btm2_ = c << half_middle_straight\n",
    "\n",
    "    mmi_out_ = c << mmi_out\n",
    "\n",
    "    # connections\n",
    "    bend_top1_.connect(\"o1\", mmi_in_.ports[\"o2\"])\n",
    "    straight_top1_.connect(\"o1\", bend_top1_.ports[\"o2\"])\n",
    "    bend_top2_.connect(\"o1\", straight_top1_.ports[\"o2\"])\n",
    "    straight_top2_.connect(\"o1\", bend_top2_.ports[\"o2\"])\n",
    "    bend_top3_.connect(\"o1\", straight_top2_.ports[\"o2\"])\n",
    "    straight_top3_.connect(\"o1\", bend_top3_.ports[\"o2\"])\n",
    "    bend_top4_.connect(\"o1\", straight_top3_.ports[\"o2\"])\n",
    "\n",
    "    straight_btm1_.connect(\"o1\", mmi_in_.ports[\"o3\"])\n",
    "    bend_btm1_.connect(\"o1\", straight_btm1_.ports[\"o2\"])\n",
    "    bend_btm2_.connect(\"o1\", bend_btm1_.ports[\"o2\"])\n",
    "    bend_btm3_.connect(\"o1\", bend_btm2_.ports[\"o2\"])\n",
    "    bend_btm4_.connect(\"o1\", bend_btm3_.ports[\"o2\"])\n",
    "    straight_btm2_.connect(\"o1\", bend_btm4_.ports[\"o2\"])\n",
    "\n",
    "    mmi_out_.connect(\"o1\", straight_btm2_.ports[\"o2\"])\n",
    "\n",
    "    # ports\n",
    "    c.add_port(\n",
    "        \"o1\",\n",
    "        port=mmi_in_.ports[\"o1\"],\n",
    "    )\n",
    "    c.add_port(\"o2\", port=mmi_out_.ports[\"o3\"])\n",
    "    c.add_port(\"o3\", port=mmi_out_.ports[\"o4\"])\n",
    "    return c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d177878a-2fca-4061-b913-efc62f1c4630",
   "metadata": {},
   "outputs": [],
   "source": [
    "compact_mzi1 = compact_mzi()\n",
    "display(compact_mzi1)\n",
    "placements = compact_mzi1.get_netlist()[\"placements\"]\n",
    "mzi3, _ = sax.circuit(compact_mzi1.get_netlist(), models=models)\n",
    "mzi3()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f55fd07a-d6ec-4024-8b7d-89100a3de1fd",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_params = sax.get_settings(mzi3)\n",
    "placements = compact_mzi1.get_netlist()[\"placements\"]\n",
    "width_params = {\n",
    "    k: {\"width\": widths(xm, ym, wmaps, v[\"x\"], v[\"y\"])}\n",
    "    for k, v in placements.items()\n",
    "    if \"width\" in mzi_params[k]\n",
    "}\n",
    "\n",
    "S0 = mzi3(wl=wl)\n",
    "S = mzi3(\n",
    "    wl=wl[:, None],\n",
    "    **width_params,\n",
    ")\n",
    "ps = plt.plot(wl * 1e3, abs(S[\"o1\", \"o2\"]) ** 2, color=\"C0\", lw=1, alpha=0.1)\n",
    "nps = plt.plot(wl * 1e3, abs(S0[\"o1\", \"o2\"]) ** 2, color=\"C1\", lw=2, alpha=1)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.plot([1550, 1550], [-1, 2], color=\"black\", ls=\":\")\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.grid(True)\n",
    "plt.figlegend([*ps[-1:], *nps], [\"MC\", \"nominal\"], bbox_to_anchor=(1.1, 0.9))\n",
    "rmse = jnp.mean(\n",
    "    jnp.abs(jnp.abs(S[\"o1\", \"o2\"]) ** 2 - jnp.abs(S0[\"o1\", \"o2\"][:, None]) ** 2) ** 2\n",
    ")\n",
    "plt.title(f\"{rmse=}\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d51f18ec-0586-4bf2-93ee-22f6656fcd09",
   "metadata": {},
   "source": [
    "## Tuning\n",
    "\n",
    "You can make a phase shifter model that depends on the applied volage. For that you need first to figure out what's the model associated to your phase shifter, and what is the parameter that you need to tune."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "100d0784-b46f-428b-882a-653b613e33bf",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "import numpy as np\n",
    "import sax\n",
    "import matplotlib.pyplot as plt\n",
    "from tqdm import trange\n",
    "import jax.numpy as jnp\n",
    "import jax"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d24fc622-6975-4d3d-8011-629bfce42abc",
   "metadata": {},
   "outputs": [],
   "source": [
    "delta_length = 10\n",
    "mzi_component = gf.components.mzi_phase_shifter_top_heater_metal(\n",
    "    delta_length=delta_length\n",
    ")\n",
    "mzi_component"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "163f7aae-8a83-4286-bccd-30ed13a1e71d",
   "metadata": {},
   "outputs": [],
   "source": [
    "def straight(wl=1.5, length=10.0, neff=2.4) -> sax.SDict:\n",
    "    wl0 = 1.5  # center wavelength for which the waveguide model is defined\n",
    "    return sax.reciprocal({(\"o1\", \"o2\"): jnp.exp(2j * jnp.pi * neff * length / wl)})\n",
    "\n",
    "\n",
    "def mmi1x2() -> sax.SDict:\n",
    "    \"\"\"Returns a perfect 1x2 splitter.\"\"\"\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): 0.5**0.5,\n",
    "            (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "def bend_euler(wl=1.5, length=20.0) -> sax.SDict:\n",
    "    \"\"\"Returns bend Sparameters with reduced transmission compared to a straight.\"\"\"\n",
    "    return {k: 0.99 * v for k, v in straight(wl=wl, length=length).items()}\n",
    "\n",
    "\n",
    "def phase_shifter_heater(\n",
    "    wl: float = 1.55,\n",
    "    neff: float = 2.34,\n",
    "    voltage: float = 0,\n",
    "    length: float = 10,\n",
    "    loss: float = 0.0,\n",
    ") -> sax.SDict:\n",
    "    \"\"\"Returns simple phase shifter model\"\"\"\n",
    "    deltaphi = voltage * jnp.pi\n",
    "    phase = 2 * jnp.pi * neff * length / wl + deltaphi\n",
    "    amplitude = jnp.asarray(10 ** (-loss * length / 20), dtype=complex)\n",
    "    transmission = amplitude * jnp.exp(1j * phase)\n",
    "    sdict = sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): transmission,\n",
    "        }\n",
    "    )\n",
    "    return sdict\n",
    "\n",
    "\n",
    "models = {\n",
    "    \"bend_euler\": bend_euler,\n",
    "    \"mmi1x2\": mmi1x2,\n",
    "    \"straight\": straight,\n",
    "    \"straight_heater_metal_undercut\": phase_shifter_heater,\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9030fb6e-3ac6-4756-96c3-cc202b467cc4",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_component = gf.components.mzi_phase_shifter_top_heater_metal(\n",
    "    delta_length=delta_length\n",
    ")\n",
    "netlist = mzi_component.get_netlist()\n",
    "mzi_circuit, _ = sax.circuit(netlist=netlist, models=models)\n",
    "S = mzi_circuit(wl=1.55)\n",
    "S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e53ed40b-1b07-4c41-92ae-e6ae5ed49836",
   "metadata": {},
   "outputs": [],
   "source": [
    "wl = np.linspace(1.5, 1.6, 256)\n",
    "S = mzi_circuit(wl=wl)\n",
    "\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.title(\"MZI\")\n",
    "plt.plot(1e3 * wl, jnp.abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "92cbb478-1c68-4cf0-b693-f873a74d79c8",
   "metadata": {},
   "source": [
    "Now you can tune the phase shift applied to one of the arms.\n",
    "\n",
    "How do you find out what's the name of the netlist component that you want to tune?\n",
    "\n",
    "You can backannotate the netlist and read the labels on the backannotated netlist or you can plot the netlist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd0e9f81-b19a-469d-8712-8c334006e24f",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_component.plot_netlist()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9a9c888c-0523-4985-ad84-26dbf4fa7891",
   "metadata": {},
   "source": [
    "As you can see the top phase shifter instance `sxt` is hard to see on the netlist.\n",
    "You can also reconstruct the component using the netlist and look at the labels in klayout."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4bc0d061-7ec4-4dad-bd22-f841ce7ff7a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_yaml = mzi_component.get_netlist_yaml()\n",
    "mzi_component2 = gf.read.from_yaml(mzi_yaml)\n",
    "fig = mzi_component2.plot(label_aliases=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da63cd80-761d-4962-ba16-0a6f8e39d10e",
   "metadata": {},
   "source": [
    "The best way to get a deterministic name of the `instance` is naming the reference on your Pcell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c687b43-a361-48c5-adc8-ac4d05f72e53",
   "metadata": {},
   "outputs": [],
   "source": [
    "voltages = np.linspace(-1, 1, num=5)\n",
    "voltages = [-0.5, 0, 0.5]\n",
    "\n",
    "for voltage in voltages:\n",
    "    S = mzi_circuit(\n",
    "        wl=wl,\n",
    "        sxt={\"voltage\": voltage},\n",
    "    )\n",
    "    plt.plot(wl * 1e3, abs(S[\"o1\", \"o2\"]) ** 2, label=str(voltage))\n",
    "    plt.xlabel(\"Î» [nm]\")\n",
    "    plt.ylabel(\"T\")\n",
    "    plt.ylim(-0.05, 1.05)\n",
    "    plt.grid(True)\n",
    "\n",
    "plt.title(\"MZI vs voltage\")\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ceffc432-a4b8-46f6-a21c-61cf788c21ec",
   "metadata": {},
   "source": [
    "## Optimization\n",
    "\n",
    "You can optimize an MZI to get T=0 at 1530nm.\n",
    "To do this, you need to define a loss function for the circuit at 1550nm.\n",
    "This function should take the parameters that you want to optimize as positional arguments:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49f066ee-4ba3-443d-a8b1-58b4f1f34c72",
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "import numpy as np\n",
    "import sax\n",
    "import matplotlib.pyplot as plt\n",
    "from tqdm import trange\n",
    "import jax.numpy as jnp\n",
    "import jax\n",
    "import jax.example_libraries.optimizers as opt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f67632f8-9166-4a73-82ae-fbe752155d11",
   "metadata": {},
   "outputs": [],
   "source": [
    "def straight(wl=1.5, length=10.0, neff=2.4) -> sax.SDict:\n",
    "    wl0 = 1.5  # center wavelength for which the waveguide model is defined\n",
    "    return sax.reciprocal({(\"o1\", \"o2\"): jnp.exp(2j * jnp.pi * neff * length / wl)})\n",
    "\n",
    "\n",
    "def mmi1x2():\n",
    "    \"\"\"Assumes a perfect 1x2 splitter\"\"\"\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): 0.5**0.5,\n",
    "            (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "def bend_euler(wl=1.5, length=20.0):\n",
    "    \"\"\" \"Let's assume a reduced transmission for the euler bend compared to a straight\"\"\"\n",
    "    return {k: 0.99 * v for k, v in straight(wl=wl, length=length).items()}\n",
    "\n",
    "\n",
    "models = {\n",
    "    \"bend_euler\": bend_euler,\n",
    "    \"mmi1x2\": mmi1x2,\n",
    "    \"straight\": straight,\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9480a4d6-e65e-416a-9010-146f57e38bd6",
   "metadata": {},
   "outputs": [],
   "source": [
    "delta_length = 30\n",
    "mzi_component = gf.components.mzi(delta_length=delta_length)\n",
    "mzi_circuit, _ = sax.circuit(netlist=mzi_component.get_netlist(), models=models)\n",
    "S = mzi_circuit(wl=1.55)\n",
    "S"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd01b45b-c710-4167-bd50-efbfff4f6bbc",
   "metadata": {},
   "outputs": [],
   "source": [
    "wl = np.linspace(1.5, 1.6, 256)\n",
    "S = mzi_circuit(wl=wl)\n",
    "\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.title(\"MZI\")\n",
    "plt.plot(1e3 * wl, jnp.abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.plot([1530, 1530], [0, 1])\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5fcdeae4-8c79-47f8-8e3d-b21f19414457",
   "metadata": {},
   "source": [
    "GDSFactory autonames component nanes for GDS and for netlists uses an incremental name for easier addressing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49a9f377-05ed-4ccf-87f6-c636b7454fb0",
   "metadata": {},
   "outputs": [],
   "source": [
    "netlist = mzi_component.get_netlist()\n",
    "gf.read.from_yaml(netlist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e910af97-5832-494f-b6d8-004474a4ad3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "gf.read.from_yaml(netlist)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "968a3e51-e729-4d84-bd7d-eced8836f410",
   "metadata": {},
   "source": [
    "From this we see that we will need to change `syl` and `straight_9`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "faf315c7-096e-47f3-ba9c-24a8fe4e37a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_component = gf.components.mzi(\n",
    "    delta_length=delta_length,\n",
    ")\n",
    "mzi_circuit, _ = sax.circuit(\n",
    "    netlist=mzi_component.get_netlist(),\n",
    "    models=models,\n",
    ")\n",
    "\n",
    "\n",
    "@jax.jit\n",
    "def loss_fn(delta_length):\n",
    "    S = mzi_circuit(\n",
    "        wl=1.53,\n",
    "        syl={\n",
    "            \"length\": delta_length / 2 + 2,\n",
    "        },\n",
    "        straight_9={\n",
    "            \"length\": delta_length / 2 + 2,\n",
    "        },\n",
    "    )\n",
    "    return (abs(S[\"o1\", \"o2\"]) ** 2).mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "081e9a8d-3c21-435b-a960-35018e7bc174",
   "metadata": {},
   "outputs": [],
   "source": [
    "%time loss_fn(20.0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9250a346-3fc8-49aa-9bf8-9dd06ba2d69e",
   "metadata": {},
   "source": [
    "You can use this loss function to define a grad function which works on the parameters of the loss function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "681cbec3-d0cb-4002-b756-58562ae3362a",
   "metadata": {},
   "outputs": [],
   "source": [
    "grad_fn = jax.jit(\n",
    "    jax.grad(\n",
    "        loss_fn,\n",
    "        argnums=0,  # JAX gradient function for the first positional argument, jitted\n",
    "    )\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f2fc61b-b946-4ffd-893f-428ec9764b10",
   "metadata": {},
   "source": [
    "Next, you need to define a JAX optimizer, which on its own is nothing more than three more functions:\n",
    "\n",
    "1. an initialization function with which to initialize the optimizer state\n",
    "2. an update function which will update the optimizer state (and with it the model parameters).\n",
    "3. a function with the model parameters given the optimizer state."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cfc972de-9f6d-45fd-9a31-30e98432e52a",
   "metadata": {},
   "outputs": [],
   "source": [
    "initial_delta_length = 30.0\n",
    "init_fn, update_fn, params_fn = opt.adam(step_size=0.1)\n",
    "state = init_fn(initial_delta_length)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bbf6243e-25b6-43ae-abd0-9911846fd282",
   "metadata": {},
   "outputs": [],
   "source": [
    "def step_fn(step, state):\n",
    "    settings = params_fn(state)\n",
    "    loss = loss_fn(settings)\n",
    "    grad = grad_fn(settings)\n",
    "    state = update_fn(step, grad, state)\n",
    "    return loss, state"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6427fb3e-defc-41ca-82cb-5692c6f504fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "range_ = trange(100)\n",
    "for step in range_:\n",
    "    loss, state = step_fn(step, state)\n",
    "    range_.set_postfix(loss=f\"{loss:.6f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ca045b90-46c1-451b-a5bb-3969e4dbc80c",
   "metadata": {},
   "outputs": [],
   "source": [
    "delta_length = params_fn(state)\n",
    "delta_length"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31f258fd-e601-491c-8766-ac80553e9ed2",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "S = mzi_circuit(\n",
    "    wl=wl,\n",
    "    syl={\"length\": delta_length / 2 + 2},\n",
    "    straight_9={\"length\": delta_length / 2 + 2},\n",
    ")\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.plot(wl * 1e3, abs(S[\"o1\", \"o2\"]) ** 2)\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.ylim(-0.05, 1.05)\n",
    "plt.plot([1530, 1530], [0, 1])\n",
    "plt.grid(True)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5cfb9dc1-f146-4637-abbd-247948fe4142",
   "metadata": {},
   "source": [
    "The minimum of the MZI is perfectly located at 1530nm."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a13a79e0-d55c-48da-89ef-be4a3a068ac2",
   "metadata": {},
   "source": [
    "## Hierarchical circuits\n",
    "\n",
    "You can also simulate hierarchical circuits, such as lattice of MZI interferometers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b3ce6f92-a37b-4588-a48e-f87a3cc26c65",
   "metadata": {},
   "outputs": [],
   "source": [
    "from typing import List\n",
    "\n",
    "import jax.numpy as jnp\n",
    "import numpy as np\n",
    "import sax\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import gdsfactory as gf\n",
    "\n",
    "\n",
    "@gf.cell\n",
    "def mzis(delta_length=10):\n",
    "    c = gf.Component()\n",
    "    c1 = c << gf.components.mzi(delta_length=delta_length)\n",
    "    c2 = c << gf.components.mzi(delta_length=delta_length)\n",
    "    c2.connect(\"o1\", c1.ports[\"o2\"])\n",
    "\n",
    "    c.add_port(\"o1\", port=c1.ports[\"o1\"])\n",
    "    c.add_port(\"o2\", port=c2.ports[\"o2\"])\n",
    "    return c\n",
    "\n",
    "\n",
    "def straight(wl=1.5, length=10.0, neff=2.4) -> sax.SDict:\n",
    "    \"\"\"Straight model.\"\"\"\n",
    "    return sax.reciprocal({(\"o1\", \"o2\"): jnp.exp(2j * jnp.pi * neff * length / wl)})\n",
    "\n",
    "\n",
    "def mmi1x2():\n",
    "    \"\"\"Assumes a perfect 1x2 splitter.\"\"\"\n",
    "    return sax.reciprocal(\n",
    "        {\n",
    "            (\"o1\", \"o2\"): 0.5**0.5,\n",
    "            (\"o1\", \"o3\"): 0.5**0.5,\n",
    "        }\n",
    "    )\n",
    "\n",
    "\n",
    "def bend_euler(wl=1.5, length=20.0):\n",
    "    \"\"\"Assumes reduced transmission for the euler bend compared to a straight.\"\"\"\n",
    "    return {k: 0.99 * v for k, v in straight(wl=wl, length=length).items()}\n",
    "\n",
    "\n",
    "models = {\n",
    "    \"bend_euler\": bend_euler,\n",
    "    \"mmi1x2\": mmi1x2,\n",
    "    \"straight\": straight,\n",
    "}\n",
    "\n",
    "\n",
    "c2 = mzis()\n",
    "c2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ac29898-157d-47b3-b9e2-69973ff7cfe1",
   "metadata": {},
   "outputs": [],
   "source": [
    "c1 = gf.components.mzi(delta_length=10)\n",
    "c1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0c5498ca-6d86-4303-8685-b3e1b993b709",
   "metadata": {},
   "outputs": [],
   "source": [
    "wl = np.linspace(1.5, 1.6)\n",
    "netlist1 = c1.get_netlist_recursive()\n",
    "circuit1, _ = sax.circuit(netlist=netlist1, models=models)\n",
    "S1 = circuit1(wl=wl)\n",
    "\n",
    "netlist2 = c2.get_netlist_recursive()\n",
    "circuit2, _ = sax.circuit(netlist=netlist2, models=models)\n",
    "S2 = circuit2(wl=wl)\n",
    "\n",
    "plt.figure(figsize=(14, 4))\n",
    "plt.plot(1e3 * wl, jnp.abs(S1[\"o1\", \"o2\"]) ** 2, label=\"1 MZI\")\n",
    "plt.plot(1e3 * wl, jnp.abs(S2[\"o1\", \"o2\"]) ** 2, label=\"2 MZI\")\n",
    "plt.xlabel(\"Î» [nm]\")\n",
    "plt.ylabel(\"T\")\n",
    "plt.grid(True)\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ba30561-3982-4a8a-8411-1ec08fc78cbe",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
