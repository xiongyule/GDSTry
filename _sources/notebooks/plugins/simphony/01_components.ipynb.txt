{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Simphony circuit simulator\n",
    "\n",
    "[Simphony](https://simphonyphotonics.readthedocs.io/en/latest/) is a circuit simulator based on [scikit-rf](https://scikit-rf.readthedocs.io/en/latest/)\n",
    "\n",
    "The main advantage of simphony over [SAX](https://flaport.github.io/sax/) is that simphony works in Windows, Linux and MacOs. While SAX only works on MacOs and Linux.\n",
    "\n",
    "It also supports the SiEPIC PDK library natively.\n",
    "\n",
    "## Component models\n",
    "\n",
    "You can use component models from :\n",
    "\n",
    "- Sparameters from Lumerical FDTD simulations thanks to the gdsfactory Lumerical plugin\n",
    "- [SiPANN](https://sipann.readthedocs.io/en/latest/?badge=latest) open source package"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import gdsfactory as gf\n",
    "\n",
    "import gdsfactory.simulation.simphony as gs\n",
    "import gdsfactory.simulation.simphony.components as gc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mzi()\n",
    "n = c.get_netlist()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c.plot_netlist()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Straight\n",
    "\n",
    "Lets start with the Sparameter model of a straight waveguide.\n",
    "\n",
    "The models are for lossless elements."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.straight()\n",
    "wavelengths = np.linspace(1500, 1600, 128) * 1e-9\n",
    "gs.plot_model(m, logscale=False, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.straight()\n",
    "wavelengths = np.linspace(1500, 1600, 128) * 1e-9\n",
    "gs.plot_model(m, phase=True, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Bend"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.bend_circular(radius=2)  # this bend should have some loss\n",
    "gs.plot_model(m, logscale=False, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.mmi1x2()  # this model comes from Lumerical FDTD 3D sims\n",
    "gs.plot_model(m, pin_in=\"o1\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.mmi1x2()  # this model comes from Lumerical FDTD 3D sims\n",
    "gs.plot_model(m, pin_in=\"o1\", pins=[\"o2\", \"o3\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.mmi1x2()\n",
    "gs.plot_model(m, pin_in=\"o1\", phase=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m.pins"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pin = m.pins[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As you can see the MMI has -20dB reflection and -3dB transmission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(m, pins=(\"o2\", \"o3\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.mmi2x2()  # this model comes from Lumerical FDTD 3D sims\n",
    "gs.plot_model(m)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_model(m, pins=(\"o3\", \"o4\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.coupler_ring()\n",
    "gs.plot_model(m, logscale=False, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gc.coupler_ring?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.coupler_ring(gap=0.3)\n",
    "gs.plot_model(m, logscale=False, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.coupler(gap=0.3)\n",
    "gs.plot_model(m, logscale=False, wavelengths=wavelengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.gc1550te()\n",
    "gs.plot_model(m, logscale=True, pin_in=\"port 1\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.gc1550te()\n",
    "gs.plot_model(m, logscale=True, pin_in=\"port 1\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = gc.gc1550te()\n",
    "gs.plot_model(m, logscale=False, pin_in=\"port 1\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Circuit simulations\n",
    "\n",
    "With Simphony you can also combine components into circuits\n",
    "\n",
    "### MZI interferometer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import gdsfactory.simulation.simphony as gs\n",
    "import gdsfactory.simulation.simphony.components as gc\n",
    "import gdsfactory as gf"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mzi(delta_length=10)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c.plot_netlist()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit = gs.components.mzi(delta_length=10, splitter=gs.components.mmi1x2)\n",
    "\n",
    "gs.plot_circuit(\n",
    "    circuit,\n",
    "    start=1500e-9,\n",
    "    stop=1600e-9,\n",
    "    logscale=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit = gs.components.mzi(delta_length=100, splitter=gs.components.mmi1x2)\n",
    "\n",
    "gs.plot_circuit(\n",
    "    circuit,\n",
    "    start=1500e-9,\n",
    "    stop=1600e-9,\n",
    "    logscale=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets add grating couplers to the mzi circuit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mzi_layout = gf.components.mzi(delta_length=100)\n",
    "mzi_with_gc_layout = gf.routing.add_fiber_single(\n",
    "    component=mzi_layout, with_loopback=False\n",
    ")\n",
    "mzi_with_gc_layout"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gc.gc1550te()\n",
    "gs.plot_model(c, pin_in=\"port 1\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### MZI interferometer from layout"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import gdsfactory as gf\n",
    "import gdsfactory.simulation.simphony as gs\n",
    "import gdsfactory.simulation.simphony.components as gc\n",
    "from simphony.libraries import siepic\n",
    "\n",
    "c = gf.components.mzi(delta_length=10)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cm = gs.component_to_circuit(c)\n",
    "gs.plot_circuit(cm)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.mzi(\n",
    "    delta_length=20\n",
    ")  # Double the delta length should reduce FSR by half\n",
    "cm = gs.component_to_circuit(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gs.plot_circuit(cm)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Ring resonator\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.ring_double(radius=5)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gc.ring_double(radius=5)\n",
    "gs.plot_circuit(c, pins_out=[\"o2\", \"o3\", \"o4\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.ring_double(radius=10)  # double radius, reduces FSR by half.\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "c = gs.components.ring_double(radius=10)\n",
    "gs.plot_circuit(c, pins_out=[\"o2\", \"o3\", \"o4\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gf.components.ring_single(radius=5)\n",
    "c"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = gs.components.ring_single(radius=10)\n",
    "gs.plot_circuit(c, pins_out=[\"o2\"])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Montecarlo variability simulation\n",
    "\n",
    "As you define your circuit models you can also include the standard deviation for each component model.\n",
    "\n",
    "For example for the waveguide model you can define:\n",
    "\n",
    "```\n",
    "sigma_ne: Standard deviation of the effective index for monte carlo simulations (default 0.05).\n",
    "sigma_ng: Standard deviation of the group velocity for monte carlo simulations\n",
    "sigma_nd: Standard deviation of the group dispersion for monte carlo simulations\n",
    "```\n",
    "\n",
    "And you can pass `runs` to change the number of Monte Carlo iterations to run.\n",
    "\n",
    "The variability values are foundry specific and they relate to the width and sigma variations from the fabrication process."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "circuit = gs.components.mzi(delta_length=10)\n",
    "\n",
    "gs.plot_circuit_montecarlo(circuit, runs=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
